#!/usr/bin/env bash
set -euo pipefail

__ScriptVersion="1.1"

E=$(printf '\033')
S="${E}[1mS${E}[0m"
function usage ()
{
echo -e "
 ___ 
/ __)
\\__ \\
(___/ - ${S}um or, ${S}imple ${S}hell ${S}cript that ${S}hall ${S}ummation in an ${S}-expre${S}${S}ion ${S}tyle

Usage :  s [[list of numbers] | [options] [file ...]]

Options:
-d delim  Specify the field delimiter.
-r        Sum by row instead of vertically.
-v        Print original input and summation result.
-h x|y    Specify a heading with the given argument(s).
          x for the header row and y for the header column.
          The specified header row or column is excluded from summation.
"
}


delim=""
verbose=0
row_wise=0
start_line=1
start_col=1

while getopts ":d:h:rvm" opt
do
  case $opt in

    d  )  delim="-F$OPTARG" ;;
    h  )  case "$OPTARG" in
              x) ((start_line+=1)) ;;
              y) ((start_col+=1)) ;;
              xy|yx) ((start_line+=1)); ((start_col+=1)) ;;
              *) echo "optarg error"; usage; exit 1 ;;
          esac ;;
    r  )  ((row_wise+=1))     ;;
    v  )  ((verbose+=1))      ;;
    m|man) tmp=$(mktemp);
        awk '/MAN_START/,/MAN_END/{if (!/START|END/) print substr($0, 2)}' $0 >$tmp;
        man $tmp;
        \rm $tmp; exit 0 ;;

    : )  usage; exit 0 ;;
    ? )  echo -e "\n  Option does not exist : $OPTARG\n"; usage;
         exit 1   ;;

  esac
done
shift $(($OPTIND-1))

# Use the first column as the header : h y -> start_col   = 2 (defult :1)
# Use the first row    as the header : h x -> start_line  = 2 (defult :1)
# Sum rowwise                        : r   -> row_wise = 1
# Output the original input as well  : v   -> verbose  = 1

awk ${delim} -vverbose=${verbose} -vrow_wise=${row_wise} -vstart_line=${start_line} -vstart_col=${start_col} '
BEGIN{
    dont_readfile = 0
    S_sum         = 0
    max_cols      = 0

    for (i = 1; i < ARGC; i++){
        if( typeof(ARGV[i]) ~ /num/){
            S_sum += ARGV[i]
            dont_readfile = 1
        }else{dont_readfile = 0}
    }
    if(dont_readfile){
        print S_sum
        exit
    }
}
NR >= start_line{
    for (i = start_col; i <= NF; i++) {
       sum[i] += $i
    }
    if(NF > max_cols) max_cols = NF
}
# row-wise addition option
row_wise>0{
    for(i=start_col;i<=NF;i++){
        row_result_sum[NR] += $i
    }
    # extend $0
    if(NR == 1 && start_line >1) {
        $(NF+1) = "_"
    }else{ $(NF+1) = row_result_sum[NR] }
}
# verbose option
verbose>0 {print $0}
END{
    if(dont_readfile || (verbose>0 && row_wise>0)) exit
    if(row_wise>0){
        for(i = start_line; i <= NR; i++) {
            print row_result_sum[i]
        }
        exit
    }
    if(NR == 1){
        for (i = start_col; i <= max_cols; i++) {
            result_sum += sum[i]
        }
    }else{
        for (i = start_col; i <= max_cols; i++) {
            result_sum = result_sum FS sum[i]
        }
        sub(FS, "", result_sum)

        if(start_col >1){
            result_sum = "_" FS result_sum
        }
    }
    print result_sum
}' "$@"

# MAN_START
#.\" Automatically generated by Pandoc 3.0.1
#.\"
#.\" Define V font for inline verbatim, using C font in formats
#.\" that render this, and otherwise B font.
#.ie "\f[CB]x\f[]"x" \{\
#. ftr V B
#. ftr VI BI
#. ftr VB B
#. ftr VBI BI
#.\}
#.el \{\
#. ftr V CR
#. ftr VI CI
#. ftr VB CB
#. ftr VBI CBI
#.\}
#.TH "s" "1" "May 2023" "version 1.1" "General Commands Manual"
#.hy
#.SH NAME
#.PP
#\f[B]s\f[R] \[em] \f[B]Sum\f[R] or, \f[B]S\f[R]lightly
#\f[B]S\f[R]killful/\f[B]S\f[R]olid/\f[B]S\f[R]imple/\f[B]S\f[R]illy
#\f[B]S\f[R]hell \f[B]S\f[R]cript that \f[B]S\f[R]hall
#\f[B]S\f[R]ummation in an \f[B]S\f[R]-expre\f[B]SS\f[R]ion
#\f[B]S\f[R]tyle with \f[B]S\f[R]avvy.
#.SH SYNOPSIS
#.PP
#\f[B]s\f[R] [list of numbers]
#.PD 0
#.P
#.PD
#\f[B]s\f[R] [\f[B]-rv\f[R]] [\f[B]-h\f[R] \f[I]headertype\f[R]] [file
#\&...]
#.SH DESCRIPTION
#.PP
#s performs one of the following:
#.IP \[bu] 2
#Sums the list of numbers given as arguments and outputs the result.
#.IP \[bu] 2
#Reads the specified file, or standard input if no file is specified,
#then prints a list of numbers summed vertically.
#When there is only one line of input, sums row-wise.
#.SH OPTIONS
#.PP
#The following options are available (in the latter case):
#.TP
#\f[B]-d\f[R] delimiter
#Specify the field delimiter.
#.TP
#\f[B]-r\f[R]
#Sum by row instead of vertically.
#.TP
#\f[B]-v\f[R]
#Print the original input and summation result.
#.TP
#\f[B]-h\f[R] x|y
#Specifies a heading with the given arguments.
#x for the header row and y for the header column.
#The specified header row or column is excluded from summation.
#.SH EXAMPLES
#.PP
#Sum arguments:
#.IP
#.nf
#\f[C]
#s 14 28
## output: 42
#
#s {1..100}
## output: 5050
#\f[R]
#.fi
#.PP
#Sum by standard input:
#.IP
#.nf
#\f[C]
#cat <<eof |s
#> 20
#> 22
#eof
## output: 42
#\f[R]
#.fi
#.PP
#Sum horizontally when the input is one line.
#.IP
#.nf
#\f[C]
#echo 21 21 |s
## output: 42
#\f[R]
#.fi
#.PP
#If there are 2 or more rows, show the sum for each column.
#.IP
#.nf
#\f[C]
#cat <<eof |s
#> 13 6 7
#> 8 5 3
#> eof
## output: 21 11 10
#\f[R]
#.fi
#.PP
#Execute \f[B]s\f[R] again with a pipe, it will print the total sum of
#all numbers.
#.IP
#.nf
#\f[C]
#cat <<eof |s|s
#> 13 6 7
#> 8 5 3
#> eof
## output: 42
#\f[R]
#.fi
# MAN_END
